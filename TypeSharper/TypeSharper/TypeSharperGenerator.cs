using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;
using Microsoft.CodeAnalysis.Text;
using TypeSharper.Diagnostics;
using TypeSharper.Model;
using TypeSharper.SemanticExtensions;

namespace TypeSharper;

[Generator]
public class TypeSharperGenerator : IIncrementalGenerator
{
    private record TargetType(TsType Type, TsAttr Attr);

    private record ModelAndTargetTypes(TsModel Model, TsList<TargetType> TargetTypes);

    private record ModelError(string ErrorMessage, INamedTypeSymbol NamedTypeSymbol);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        RegisterTypeGeneratorAttributes(context);

        RegisterTypeGeneratorSupportTypes(context);

        context.RegisterSourceOutput(
            TsModelAndTargetTypes(context),
            (sourceProductionContext, modelCreationResult) =>
            {
                RunDiagnostics(modelCreationResult, sourceProductionContext)
                    .IfSome(
                        modelAndTargetTypes =>
                        {
                            var generatedModel =
                                modelAndTargetTypes.TargetTypes.Aggregate(
                                    modelAndTargetTypes.Model,
                                    (genMod, targetType) =>
                                        genMod.AddGeneratedType(
                                            TsTypeFactory.Create(targetType.Type.Info, targetType.Attr, genMod)));

                            var syntaxTreesWithPaths =
                                generatedModel
                                    .GeneratedTypeDict
                                    .Values
                                    .Select(
                                        generatedType =>
                                        {
                                            var syntaxTree =
                                                CSharpSyntaxTree.ParseText(generatedType.CsFile(generatedModel));

                                            var filePath =
                                                generatedType
                                                    .Ref()
                                                    .Name
                                                    .Parts
                                                    .Select(id => id.Cs())
                                                    .JoinPath();

                                            return (tree: syntaxTree,
                                                filePath: $"{filePath}{generatedType.Info.Name.Value}.g");
                                        })
                                    .ToList();

                            foreach (var treeWithPath in syntaxTreesWithPaths)
                            {
                                sourceProductionContext.AddSource(
                                    treeWithPath.filePath,
                                    $$"""
                                    //-----------------------------------------------------------------------//
                                    // <auto-generated>                                                      //
                                    // This code was generated by TypeSharper.                               //
                                    //                                                                       //
                                    // Changes to this file may cause incorrect behavior and will be lost if //
                                    // the code is regenerated.                                              //
                                    // </auto-generated>                                                     //
                                    //-----------------------------------------------------------------------//

                                    {{SimplifyUsings(treeWithPath.tree.GetCompilationUnitRoot())}}
                                    """);
                            }
                        });
            });
    }

    private static string SimplifyUsings(CompilationUnitSyntax root)
    {
        var simplifiedRoot = root;
        // while (true)
        // {
        //     var nameSyntax = simplifiedRoot
        //                      .DescendantNodes()
        //                      .OfType<QualifiedNameSyntax>()
        //                      .FirstOrDefault(
        //                          syntax => syntax.Parent
        //                              is not BaseNamespaceDeclarationSyntax
        //                              and not UsingStatementSyntax
        //                              and not UsingDirectiveSyntax);
        //
        //     if (nameSyntax == null)
        //     {
        //         break;
        //     }
        //
        //     var simpleName = nameSyntax.Right;
        //     var namespaceName = nameSyntax.Left.ToString();
        //
        //     simplifiedRoot = simplifiedRoot.ReplaceNode(nameSyntax, simpleName);
        //
        //     if (simplifiedRoot.Usings.All(u => u.Name?.ToString() != namespaceName))
        //     {
        //         var usingDirective = SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(namespaceName));
        //         simplifiedRoot = simplifiedRoot.AddUsings(usingDirective);
        //     }
        // }

        return Formatter.Format(simplifiedRoot.NormalizeWhitespace(), new AdhocWorkspace()).ToFullString();
    }

    #region Private

    private static IEnumerable<INamedTypeSymbol> CollectDependentTypes(INamedTypeSymbol namedTypeSymbol)
        => namedTypeSymbol
           .TsAttributes()
           .SelectMany(
               attributeData => attributeData
                                .AttributeClass
                                ?.TypeArguments
                                .Select(arg => arg))
           .Concat(namedTypeSymbol.ContainingTypeHierarchy())
           .Select(depType => (INamedTypeSymbol)depType);

    private static EitherOr<ModelAndTargetTypes, ModelError> CreateModel(IEnumerable<INamedTypeSymbol> namedTypeSymbols)
        => namedTypeSymbols
           .Distinct<INamedTypeSymbol>(SymbolEqualityComparer.Default)
           .Aggregate(
               EitherOr<ModelAndTargetTypes, ModelError>
                   .Either(new ModelAndTargetTypes(TsModel.New(), TsList<TargetType>.Empty)),
               (eitherOr, typeSymbol) => eitherOr.IfEither(
                   modelAndTargetTypes =>
                   {
                       if (typeSymbol.Kind == SymbolKind.ErrorType)
                       {
                           return new ModelError($"The symbol {typeSymbol.Name} contains an error", typeSymbol);
                       }

                       var (model, targetTypes) = modelAndTargetTypes;

                       var tsType = typeSymbol.ToType();

                       var tsAttrs =
                           TsList.Create(
                               typeSymbol
                                   .TsAttributes()
                                   .Select(AttributeDataExtensions.ToAttr)
                                   .Where(maybeAttr => maybeAttr.Map(_ => true, () => false))
                                   .Select(maybeAttr => maybeAttr.AssertSome()));

                       if (tsAttrs.Count > 1)
                       {
                           return new ModelError(
                               $"""
                               The symbol {typeSymbol.Name} has more than one TypeSharper attribute:
                               {tsAttrs.Select(attr => $"* {attr.GetType().Name}").JoinLines()}
                               """,
                               typeSymbol);
                       }

                       return new ModelAndTargetTypes(
                           model.AddType(tsType),
                           tsAttrs.Count == 0
                               ? targetTypes
                               : targetTypes.Add(new TargetType(tsType, tsAttrs.Single())));
                   }));

    private static IEnumerable<INamedTypeSymbol> OrderTypesTopologicallyByDependencies(
        IEnumerable<INamedTypeSymbol> types)
    {
        var depGraph = new TypeDependencyGraph();

        foreach (var type in types)
        {
            depGraph.Add(type);
            foreach (var dependentTypeSymbol
                     in type
                        .TypeSharperAttribute()
                        .SelectMany(attributeData => attributeData.AttributeClass?.TypeArguments.ToList())
                        .OfType<INamedTypeSymbol>())
            {
                depGraph.AddDependency(type, dependentTypeSymbol);
            }
        }

        var typesOrderedTopologicallyByDependencies =
            depGraph.OrderTypesTopologicallyByDependencies();

        return typesOrderedTopologicallyByDependencies;
    }

    private static Maybe<ModelAndTargetTypes> RunDiagnostics(
        EitherOr<ModelAndTargetTypes, ModelError> modelCreationResult,
        SourceProductionContext sourceProductionContext)
        => modelCreationResult.Map(
            modelAndTargetTypes =>
                modelAndTargetTypes
                    .TargetTypes
                    .All(
                        typeAndAttr =>
                            Diag.RunTypeHierarchyIsPartialDiagnostics(
                                sourceProductionContext,
                                modelAndTargetTypes.Model,
                                typeAndAttr.Type)
                            && Diag.RunTypeIsRecordDiagnostics(sourceProductionContext, typeAndAttr.Type))
                    ? modelAndTargetTypes
                    : Maybe<ModelAndTargetTypes>.NONE,
            modelError =>
            {
                EDiagnosticsCode.ModelCreationFailedBecauseOfSymbolError.ReportError(
                    sourceProductionContext,
                    $"""
                    {modelError.ErrorMessage}.
                    The corresponding symbol is {0}.
                    """,
                    modelError.NamedTypeSymbol);
                return Maybe<ModelAndTargetTypes>.NONE;
            });

    private static IncrementalValueProvider<EitherOr<ModelAndTargetTypes, ModelError>> TsModelAndTargetTypes(
        IncrementalGeneratorInitializationContext context)
        => context
           .SyntaxProvider
           .CreateSyntaxProvider(
               (s, _)
                   => s is InterfaceDeclarationSyntax
                       or ClassDeclarationSyntax
                       or StructDeclarationSyntax
                       or RecordDeclarationSyntax,
               (ctx, cancellationToken)
                   =>
               {
                   var namedTypeSymbol =
                       (INamedTypeSymbol)ctx.SemanticModel.GetDeclaredSymbol(ctx.Node, cancellationToken)!;
                   return namedTypeSymbol.HasTsAttribute()
                       ? TsList.Create(CollectDependentTypes(namedTypeSymbol).Append(namedTypeSymbol))
                       : TsList.Create<INamedTypeSymbol>();
               })
           .SelectMany((x, _) => x)
           .Collect()
           .Select(
               (typeSymbols, _)
                   => CreateModel(OrderTypesTopologicallyByDependencies(typeSymbols)));

    private static void RegisterTypeGeneratorAttributes(IncrementalGeneratorInitializationContext context)
    {
        foreach (var attrDef in TypeSharperAttributes.Attributes())
        {
            context.RegisterPostInitializationOutput(
                ctx
                    => ctx.AddSource(
                        $"{attrDef.Name.Value}.g.cs",
                        SourceText.From(attrDef.Cs(), Encoding.UTF8)));
        }
    }

    private void RegisterTypeGeneratorSupportTypes(IncrementalGeneratorInitializationContext context)
    {
        var assembly = GetType().Assembly;
        var supportTypeSourceCodes = new[]
        {
            (src: assembly.ReadEmbeddedResource("Support.Maybe.cs"), 
                file: "Support/Maybe.g.cs"),
            
            (src: assembly.ReadEmbeddedResource("Support.Void.cs"), 
                file: "Support/Void.g.cs"),
        };
        foreach (var (src, file) in supportTypeSourceCodes)
        {
            context.RegisterPostInitializationOutput(
                ctx =>
                    ctx.AddSource(file, SourceText.From(src, Encoding.UTF8)));
        }
    }

    #endregion
}
